Jake Walker
103467429

Compilation instructions:
1. create new project in Visual Studio
2. include the Printing.cpp file in that project
3. compile
4. use the Printing.exe file in the debug folder for test

Algorithms used:
	I had two main parts- one to determine the line spacing, and one to determine the correct output format (I looked into doing both at once, but decided that I had too many other projects due to justify going for the challenge XD)
	The first algorithm determined line spacing by filling in an array of ints.  The value of the array at indicie i is the value of the next indicie in a valid word spacing of all previously seen characters up to and including the ith character on that line (there are two exceptions: if the first letter is in itself a word, the value -2 is used, due to an unforseen bug.  In my original implementation, words indicated that they were complete by having a 0 value, but if 0 is the correct word, not just the end marker, then we're in trouble! the other exception is that -1 is used if there exists no valid parseing of all previous characters).  For example, the string "Ilikefood" produces the spae array [-2,-1,-1,-1,0,-1,-1,-1,4] (assuming only the words "I", "like", and "food" are in our dictionary).  Thus, by examining the last element of the array, we can see both whether or not is has a valid parseing (indicated by a non-negative value) and where to procede if it does in fact have a valid parseing (go look at array index 4).  This array is constructed by starting at the end of the currently proccessed characters, and proceeding leftwards.  If that subset of characters is a word AND the subset of all previous characters has a valid parseing, then we give the indicie the value of the rightmost character of those previous characters (i.e, if "foods" was also in our dictionary, we would process the last s by checking the words "s", "ds", "ods", "oods", and finally "foods".  We see that foods is in fact a word, so we check if "Ilike" has a valid parseing.  It does, so we set the array value of that s character's location (location 9) to be 4.
	Once this process is completed, we have a valid parseing of the word by looking at the last value of that array.  Then we must space it.  This is done in a simillar fashion.  We define an array_entry as having two ints- one for the leftmost word index in the line, and one for the current cumulative cost of the paragraph.  We can build an array of array_entries by considering all possible "last line" scenarios.  That is, the last line either consists of just the last word, or the last two words, or the last three words, and so on, until the value of all the last n words added together (plus the spaces) is larger that the total acceptable line size.  The array_entry's min_value field is set equal to the min over all such last line combinations of the array_entry min value of the word right before the beggining of the "last line" plus the cube of the ideal line length minus the current line length.  For example, if we have the sentence "I like food a lot", we have a word length array of [1, 4, 4, 1, 3].  Supposing our maximum line length is 6, it is clear that "I like" will be in the first line, and that line will have a min value of 0.  We come to the word "food".  The last line can contain just the word "food", and thus has a value of the min value of "I like" (0) + (6 - |food|)^3 = 8.  looking at the word "a", the last line either contains just a, and thus has a cumulative cost of outputting "I like food" (8) + (6-|a|)^3 = 133, or the last line contains "food a", in which case it has a cumulative cost of outputting "I like" (0) + (6 - |food a|) ^ 3 = 0!  Since the second is the min, we set paragraph[4] = (0, 2) (the min value to output, and the index of the last word in the line right above it, starting from 1).
	Clearly, these both use dynamic programming, and perhaps looking at the code will be more informative.  Happy hunting :)
	Oh, and as far as I know, everything works, including one line inputs, one word inputs, inputs starting with a single letter word, inputs having exactly the right length to fit, and all other tricky cases I could come up with.